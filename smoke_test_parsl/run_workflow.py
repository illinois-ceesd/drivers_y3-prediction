#!/usr/bin/env python3

import parsl
from parsl.config import Config
from parsl.providers import LSFProvider, SlurmProvider
from parsl.executors import HighThroughputExecutor, ThreadPoolExecutor
from parsl.launchers import JsrunLauncher, SrunLauncher
from parsl.addresses import address_by_hostname
from parsl.app.app import bash_app, python_app

executor_name = "my_executor"
host = address_by_hostname()
if 'lassen' in host.lower():
    executor = HighThroughputExecutor(
        label=executor_name,
        address=address_by_hostname(),
        worker_debug=True,
        provider=LSFProvider(launcher=JsrunLauncher(overrides=''),
            walltime='01:00:00',
            nodes_per_block=1,
            init_blocks=1,
            max_blocks=1,
            bsub_redirection=True,
            queue='pdebug',
            worker_init=(
                "module load spectrum-mpi\n"
                "source emirge/miniforge3/bin/activate mirgeDriver.Y3prediction\n"
                "export PYOPENCL_CTX=port:tesla\n"
                "export XDG_CACHE_HOME=/tmp/$USER/xdg-scratch\n"),
            project='uiuc')
        )
elif 'quartz' in host.lower():
    executor = HighThroughputExecutor(label=executor_name,
        address=address_by_hostname(),
        worker_debug=True,
        provider=SlurmProvider(launcher=SrunLauncher(overrides=''),
            walltime='01:00:00',
            nodes_per_block=1,
            init_blocks=1,
            max_blocks=1,
            scheduler_options='#SBATCH -q pdebug',
            worker_init=(
                "module load spectrum-mpi\n"
                "source emirge/miniforge3/bin/activate mirgeDriver.Y3prediction\n"
                "export XDG_CACHE_HOME=/tmp/$USER/xdg-scratch\n"),
            )
        )
else:
    executor = ThreadPoolExecutor(label=executor_name)

config = Config(executors=[executor])
parsl.load(config)

@bash_app(executors=[executor_name])
def _mpirun(module="driver.py", yml="run_params.yaml", c=None, t=None, r=None, lazy=True):
    """ Generate and return the mpirun command line based on inputs

        Parameters
        ----------
        module: the python module to run (default is "driver.py")
        yml: the name of the yaml comtrol file (default is "run_params.yaml")
        c: the file name to pass to the -c argument of the module (default is None, i.e. do not set the argument)
        t: the file name to pass to the -t argument of the module (default is None, i.e. do not set the argument)
        r: the file name to pass to the -r argument of the module (default is None, i.e. do not set the argument)
        lazy: boolean, whether to set the lazt flag for the module
    """
    cmd = f"mpirun -n 1 python -u -O -m mpi4py {module} -i {yml} --log"
    if lazy:
        cmd += " --lazy"
    if t:
        cmd += f" -t {t}"
    if r:
        cmd += f" -r {r}"
    if c:
        cmd += f" -c {c}"
    print(f"\n\n{cmd}\n\n")
    return cmd


@python_app(executors=[executor_name])
def mpirun(directory="", filepat="", module="driver.py", yml="run_params.yaml", c=None, t=None, r=None, lazy=True, inputs=[], outputs=[]):
    """ Set up, generate, and run the mpirun command.

        Parameters
        ----------
        directory: the directory to cd into
        filepat: the file pattern to look for output files (e.g. 'prediction-000000100')
        module: the python module to run (default is "driver.py")
        yml: the name of the yaml comtrol file (default is "run_params.yaml")
        c: the file name to pass to the -c argument of the module (default is None, i.e. do not set the argument)
        t: the file name to pass to the -t argument of the module (default is None, i.e. do not set the argument)
        r: the file name to pass to the -r argument of the module (default is None, i.e. do not set the argument)
        lazy: boolean, whether to set the lazt flag for the module
        inputs: list of parsl.File objects giving any input files
        outputs: list of parsl.File objects generated by this operation (given as an empty list and populated by this function)

    """
    import os
    import shutil
    import glob
    from parsl.data_provider.files import File
    print(f"**********************   STARTING   {directory}    ******************")
    cwd = os.getcwd()

    try:
        run = _mpirun(module=module, yml=yml, c=c, t=t, r=r, lazy=lazy)
        try:
            if run.result() != 0:
                raise Exception(f"mpirun failed with exit code {run.result()}")
        except:
            raise
        #if filepat:
            #for fname in glob.glob(f"{os.getcwd()}/restart_data/{filepat}*"):
                #outputs.append(File(fname))
    finally:
        os.chdir(cwd)
        print(f"*******************************   FINISHED {directory} ***************************")


def monitor_restart(file, outputs=[]):
    """ Monitor the restart directory for existence of a file

        Parameters
        ----------
        file: the file to look for
        outputs: list of parsl.File objects generated by this operation (given as an empty list and populated by this function)

    """
    import os
    from parsl.data_provider.files import File
    import time

    target_file = "{os.getcwd()}/restart_data/{file}"
    abort_file = "{os.getcwd()}/stop_workflow"
    filenotfound = True
    delay = 15

    while filenotfound:
        if os.path.isfile(target_file):
            outputs.append(File(target_file))
            filenotfound = False

        if os.path.isfile(abort_file):
            filenotfound = False

        time.sleep(delay)


def main():

    #######
    # 1. run mirgecom and generate restart_data
    #######

    # we need to know a priori what the outfiles files generated will be,
    # so parsl can generate futures for data dependency
    run_restart_files = ["restart_data/prediction-000000000-0000.pkl",
                         "restart_data/prediction-000000005-0000.pkl",
                         "restart_data/prediction-000000010-0000.pkl",
                         "restart_data/prediction-000000015-0000.pkl",
                         "restart_data/prediction-000000020-0000.pkl"]

    parsl_restart_outfile = []
    from parsl.data_provider.files import File
    import os
    for restart_file in run_restart_files:
        parsl_restart_outfile.append(File(os.path.join(os.getcwd(), restart_file),))

    run_mirge = mpirun(directory="run mirgecom", yml="run_params.yaml", outputs=parsl_restart_outfile, lazy=False)
    run_mirge.result()  # wait until it is done
    print(run_mirge.outputs)

    """
    run_viz_files = ["viz_data/prediction-000000000-0000.pkl",
                     "restart_data/prediction-000000005-0000.pkl",
                         "restart_data/prediction-000000010-0000.pkl",
                         "restart_data/prediction-000000015-0000.pkl",
                         "restart_data/prediction-000000020-0000.pkl"]

    """
    #######
    # 2. run mirgecom and generate viz_data from restart data
    #######

    make_viz_data = []
    for future in run_mirge.outputs:
        # first figure out the names of the viz files to be created
        # so we can make data futures for them
        print(future.filename)
        restart_name = os.path.basename(future.filename)
        # remove extension
        restart_name = os.path.splitext(restart_name)[0]
        # remove rank number
        restart_name = restart_name[:len(restart_name)-5]
        # get dump number and the casename
        dump_number = restart_name[len(restart_name)-9:]
        case_name = restart_name[:len(restart_name)-10]
        print(restart_name)
        print(case_name)
        print(dump_number)
        # construct dump name
        viz_name_fluid = (f"viz_data/{case_name}-fluid-{dump_number}.pvtu")
        viz_name_wall = (f"viz_data/{case_name}-wall-{dump_number}.pvtu")
        print(viz_name_fluid)
        print(viz_name_wall)

        parsl_viz_outfile = []
        parsl_viz_outfile.append(File(os.path.join(os.getcwd(), viz_name_fluid),))
        parsl_viz_outfile.append(File(os.path.join(os.getcwd(), viz_name_wall),))


        # run mirge and make the viz files
        make_viz_data.append(mpirun(directory=f"viz {dump_number}",
                                    yml="make_viz_params.yaml",
                                    r=f"restart_data/{restart_name}",
                                    inputs=[future],
                                    outputs=parsl_viz_outfile,
                                    lazy=False))

    #make_viz_data[0].result()  # wait until it is done
    #print(make_viz_data[0].outputs)
    print("waiting for viz to finish?")
    print(len(make_viz_data))
    print(make_viz_data)
    loop_ind = 0
    for i in make_viz_data:
        print(f"{loop_ind=}")
        print(i)
        print(i.task_status())
        i.result()
        print("after result")
        print(i.outputs)
        print("after outputs")
        loop_ind = loop_ind + 1

    #viz_output = [i.result() for i in make_viz_data]
    #print(viz_output)


if __name__ == "__main__":
    main()
